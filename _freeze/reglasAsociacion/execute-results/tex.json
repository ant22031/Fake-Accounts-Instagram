{
  "hash": "9d27194fbe42aa9ee6097fb5af475767",
  "result": {
    "engine": "knitr",
    "markdown": "# Reglas de asociación\n\nVamos a utilizar reglas de asociación para detectar cuentas falsas en Instagram. Las reglas de asociación son técnicas de minería de datos que permiten descubrir relaciones interesantes y útiles entre diferentes características o comportamientos observados en el dataSet.\n\nPara realizar estas operaciones vamos a utilizar el paquete `arules.`\n\n## Características importantes\n\n### Medidas relevantes\n\nPara evaluar la calidad y relevancia de las reglas de asociación, vamos a utilizar las medidas de:\n\n1.  **Soporte (Support)**:\n\n    -   El soporte de una regla mide la proporción de cuentas en el dataset que contienen ambos conjuntos de características A y B.\n\n    -   Un soporte alto indica que la regla se aplica a una gran proporción del dataset, lo que sugiere que la combinación de características es común y relevante.\n\n2.  **Confianza (Confidence)**:\n\n    -   La confianza de una regla mide cuán frecuentemente las características en B aparecen en las cuentas que contienen A.\n\n    -   A mayor confianza, mayor es la fiabilidad de que la presencia de las características en el antecedente de la regla (A) implicará la presencia de las características en el consecuente de la regla (B).\n\n3.  **Elevación (Lift)**:\n\n    -   La elevación mide la relación entre la aparición conjunta de A y B y la aparición esperada de A y B si fueran independientes.\n\n    -   Una elevación alta (mayor que 1) indica que la presencia de A incrementa significativamente la probabilidad de que B ocurra, lo que sugiere una fuerte asociación entre las características.\n\n### Algoritmo Apriori\n\nVamos a utilizar el algoritmo Apriori como nuestra forma de obtener reglas a partir de nuestros datos. Este es uno de los algoritmos más conocidos y se basa en la propiedad de que cualquier subconjunto de un conjunto frecuente también debe ser frecuente. El algoritmo itera a través de los conjuntos de características, incrementando su tamaño en cada iteración y manteniendo solo los conjuntos que cumplen con un umbral mínimo de soporte.\n\n### Reglas\n\nLas reglas de asociación consisten en implicaciones del tipo \"Si A entonces B\", donde A y B son conjuntos de características o comportamientos de las cuentas. Por ejemplo, una regla podría ser \"Si una cuenta tiene un número alto de cuentas seguidos y no tiene foto de perfil, entonces es probable que sea una cuenta falsa\".\n\n## Cargar datos\n\nVamos a cargar las librería necesarias y nuestro dataSet:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(arules)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Matrix\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'arules'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    abbreviate, write\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(arulesViz)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'arulesViz' was built under R version 4.3.3\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(readr)\ndatos <- read_csv(\"Data/train.csv\") \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 576 Columns: 12\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\ndbl (12): profile pic, nums/length username, fullname words, nums/length ful...\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\n## Discretizar datos\n\nPuesto que el algoritmo de apriori necesita que el conjunto de datos sea binario o discreto.\n\nExisten varias formas de discretizar datos, pero el objetivo principal es convertir las características continuas en valores discretos que representen de manera efectiva la información subyacente. Algunas técnicas comunes de discretización incluyen la binarización, la división en intervalos fijos o basados en cuantiles.\n\nTras haber realizado el previo análisis exploratorio podemos definir intervalos personalizados para las cada variable, para ello usaremos las funciones ordered y cut. Ademas las variables que son binarias como fake, vamos a ponerle \"Si\" o \"No\" para poder comprenderlo mejor.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_refinados <- datos\n\ncolumnas_binarias = c(\"profile pic\",\"name==username\",\"external URL\",\"fake\",\"private\")\n\nfor (columna in columnas_binarias) {\n  datos_refinados[[columna]] <-  factor(datos_refinados[[columna]], labels = c(\"No\", \"Si\"))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Discretización de la columna #posts\ndatos_refinados$`#posts` <- ordered(cut(datos_refinados$`#posts`, \n                                 breaks = c(0,1, 5, 10, 50, Inf), \n                                 labels = c(\"muy bajo\",\"medio\", \"alto\", \"muy alto\", \"extremadamente alto\"),include.lowest = TRUE))\n\n# Discretización de la columna #followers\ndatos_refinados$`#followers` <- ordered(cut(datos_refinados$`#followers`, \n                                     breaks = c(0, 10, 60, 200, Inf), \n                                     labels = c(\"bajo\", \"medio\", \"alto\", \"muy alto\"),include.lowest = TRUE))\n\n# Discretización de la columna #follows\ndatos_refinados$`#follows` <- ordered(cut(datos_refinados$`#follows`, \n                                   breaks = c(0, 10, 60, 200, Inf), \n                                   labels = c(\"bajo\", \"medio\", \"alto\", \"muy alto\"),include.lowest = TRUE))\n\n# Discretización de la columna nums/length username\ndatos_refinados$`nums/length username` <- ordered(cut(datos_refinados$`nums/length username`,\n                                                      breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1),\n                                                      labels = c(\"muy bajo\", \"bajo\", \"medio\", \"alto\", \"muy alto\"),\n                                                      include.lowest = TRUE))\n\n# Discretización de la columna nums/length fullname\ndatos_refinados$`nums/length fullname` <- ordered(cut(datos_refinados$`nums/length fullname`, \n                                                      breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1), \n                                                      labels = c(\"muy bajo\", \"bajo\", \"medio\", \"alto\", \"muy alto\"),\n                                                      include.lowest = TRUE))\n# Discretización de la columna description length\ndatos_refinados$`description length` <- ordered(cut(datos_refinados$`description length`,\n                                                     breaks = c(0, 15, 25, 80, 150),\n                                                     labels = c(\"muy corto\" , \"medio\", \"largo\", \"muy largo\"),\n                                                    include.lowest = TRUE))\n# Discretización de la columna fullname words\ndatos_refinados$`fullname words` <- ordered(cut(datos_refinados$`fullname words`,\n                                                 breaks = c(0, 1, 3, 5, Inf),\n                                                 labels = c(\"muy corto\", \"medio\", \"largo\", \"muy largo\"),include.lowest = TRUE))\n```\n:::\n\n\n\n### discretizeDF\n\nEsta función del paquete de arules implementa varios métodos básicos no supervisados para convertir una variable continua en una variable categórica (factor) usando diferentes estrategias de agrupamiento.\n\nVamos a quitar primero las columnas binarias que le queremos poner un valor custom.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_refinados_clone <- datos\n\ncolumnas_binarias = c(\"profile pic\",\"name==username\",\"external URL\",\"fake\",\"private\")\n\nfor (columna in columnas_binarias) {\n  datos_refinados_clone[[columna]] <-  factor(datos_refinados_clone[[columna]], labels = c(\"No\", \"Si\"))\n}\n```\n:::\n\n\n\nVamos a ver algunas estrategias:\n\n#### K-means:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkmeansDisc <- discretizeDF(datos_refinados_clone, default = list(method = \"cluster\", breaks = 5, \n  labels = c(\"muy bajo\", \"bajo\",\"medio\",\"alto\",\"muy alto\")))\nhead(kmeansDisc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 12\n  `profile pic` `nums/length username` `fullname words` `nums/length fullname`\n  <fct>         <fct>                  <fct>            <fct>                 \n1 Si            bajo                   muy bajo         muy bajo              \n2 Si            muy bajo               bajo             muy bajo              \n3 Si            muy bajo               bajo             muy bajo              \n4 Si            muy bajo               bajo             muy bajo              \n5 Si            muy bajo               bajo             muy bajo              \n6 Si            muy bajo               medio            muy bajo              \n# i 8 more variables: `name==username` <fct>, `description length` <fct>,\n#   `external URL` <fct>, private <fct>, `#posts` <fct>, `#followers` <fct>,\n#   `#follows` <fct>, fake <fct>\n```\n\n\n:::\n:::\n\n\n\n#### interval\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfixedDisc <- discretizeDF(datos_refinados_clone, default = list(method = \"interval\", breaks = 5, \n  labels = c(\"muy bajo\", \"bajo\",\"medio\",\"alto\",\"muy alto\")))\nhead(fixedDisc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 12\n  `profile pic` `nums/length username` `fullname words` `nums/length fullname`\n  <fct>         <fct>                  <fct>            <fct>                 \n1 Si            bajo                   muy bajo         muy bajo              \n2 Si            muy bajo               muy bajo         muy bajo              \n3 Si            muy bajo               muy bajo         muy bajo              \n4 Si            muy bajo               muy bajo         muy bajo              \n5 Si            muy bajo               muy bajo         muy bajo              \n6 Si            muy bajo               bajo             muy bajo              \n# i 8 more variables: `name==username` <fct>, `description length` <fct>,\n#   `external URL` <fct>, private <fct>, `#posts` <fct>, `#followers` <fct>,\n#   `#follows` <fct>, fake <fct>\n```\n\n\n:::\n:::\n\n\n\n## Generar dataset de transacciones\n\nAhora una vez discretizado el dataframe, el siguiente paso es generar un dataset de transacciones. Este tipo de dataset es esencial para aplicar algoritmos de reglas de asociación como Apriori.\n\nEn un dataset de transacciones, cada fila representa una transacción, que es una colección de elementos o ítems.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_refinadosT <- as(datos_refinados, \"transactions\")\n```\n:::\n\n\n\n## Generar reglas\n\nAhora que ya tenemos todo listo, podemos utilizar los algoritmos de generacion de reglas. En nuestro caso, vamos a utilizar apriori. Para generar reglas primero necesitamos establecer un valor para el suport y confianza minima, estos valores nos permitirán controlar la cantidad y calidad de las reglas que se generarán.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n rules <- apriori(datos_refinadosT,  parameter = list(supp = 0.3, conf = 0.01, target = \"rules\")) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nApriori\n\nParameter specification:\n confidence minval smax arem  aval originalSupport maxtime support minlen\n       0.01    0.1    1 none FALSE            TRUE       5     0.3      1\n maxlen target  ext\n     10  rules TRUE\n\nAlgorithmic control:\n filter tree heap memopt load sort verbose\n    0.1 TRUE TRUE  FALSE TRUE    2    TRUE\n\nAbsolute minimum support count: 172 \n\nset item appearances ...[0 item(s)] done [0.00s].\nset transactions ...[40 item(s), 576 transaction(s)] done [0.00s].\nsorting and recoding items ... [16 item(s)] done [0.00s].\ncreating transaction tree ... done [0.00s].\nchecking subsets of size 1 2 3 4 5 6 7 done [0.00s].\nwriting ... [1157 rule(s)] done [0.00s].\ncreating S4 object  ... done [0.00s].\n```\n\n\n:::\n\n```{.r .cell-code}\n rules\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nset of 1157 rules \n```\n\n\n:::\n:::\n\n\n\nHemos obtenido una buena cantidad de reglas para continuar nuestro análisis.\n\n## Refinar reglas\n\nAhora que hemos obtenido las reglas necesitamos cribarlarlas y eliminar todas aquellas que no nos interesan, que sean redundantes o no significativas.\n\n### Eliminar reglas redundantes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrules <- rules[which(is.redundant(rules))]\n```\n:::\n\n\n\n### Eliminar reglas no significativas\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrules <- rules[which(is.significant(rules))]\n```\n:::\n\n\n\nVamos a ver cuentas reglas han quedado después de filtrarlas:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(rules)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 569\n```\n\n\n:::\n:::\n\n\n\n## Análisis de reglas obtenidas\n\nNuestro objetivo es detectar y diferenciar cuentas falses de las verdaderas, por lo tanto, vamos a centrar nuestro analisis en eso dos atributos \"fake=Si\" y \"fake=No\". Como tenemos diferentes metricas, vamos a analizarlas por separado:\n\n### Support:\n\nVamos priemro a analizar las reglas ordenando primero por el soporte de la reglas. Recordamos que el soporte alto indica que la regla se aplica a una gran proporción del dataset, lo que sugiere que la combinación de características es común y relevante.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrules <- sort(rules,by=\"support\")\ninspect(head(rules))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    lhs                                 rhs                               support confidence  coverage     lift count\n[1] {nums/length fullname=muy bajo,                                                                                  \n     external URL=No}                => {name==username=No}             0.7881944  0.9848156 0.8003472 1.020241   454\n[2] {nums/length username=muy bajo,                                                                                  \n     name==username=No}              => {nums/length fullname=muy bajo} 0.6250000  0.9863014 0.6336806 1.078007   360\n[3] {nums/length fullname=muy bajo,                                                                                  \n     name==username=No}              => {nums/length username=muy bajo} 0.6250000  0.6936416 0.9010417 1.071146   360\n[4] {name==username=No,                                                                                              \n     description length=muy corto}   => {external URL=No}               0.6041667  0.9747899 0.6197917 1.103102   348\n[5] {name==username=No,                                                                                              \n     external URL=No}                => {description length=muy corto}  0.6041667  0.7102041 0.8506944 1.096723   348\n[6] {nums/length fullname=muy bajo,                                                                                  \n     description length=muy corto}   => {external URL=No}               0.5590278  0.9728097 0.5746528 1.100861   322\n```\n\n\n:::\n:::\n\n\n\nEn este caso, el soporte es 0.7881944, lo que significa que el 78.82% de las transacciones en el dataset contienen tanto el antecedente {nums/length fullname=muy bajo, external URL=No} como el consecuente {name==username=No}.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2 <- subset(rules, subset = rhs %in% c(\"fake=Si\"))\ninspect(head(r2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    lhs                                 rhs         support confidence  coverage     lift count\n[1] {name==username=No,                                                                        \n     external URL=No}                => {fake=Si} 0.4670139  0.5489796 0.8506944 1.097959   269\n[2] {name==username=No,                                                                        \n     description length=muy corto}   => {fake=Si} 0.4253472  0.6862745 0.6197917 1.372549   245\n[3] {name==username=No,                                                                        \n     description length=muy corto,                                                             \n     external URL=No}                => {fake=Si} 0.4253472  0.7040230 0.6041667 1.408046   245\n[4] {nums/length fullname=muy bajo,                                                            \n     external URL=No}                => {fake=Si} 0.4218750  0.5271150 0.8003472 1.054230   243\n[5] {nums/length fullname=muy bajo,                                                            \n     description length=muy corto}   => {fake=Si} 0.3819444  0.6646526 0.5746528 1.329305   220\n[6] {nums/length fullname=muy bajo,                                                            \n     description length=muy corto,                                                             \n     external URL=No}                => {fake=Si} 0.3819444  0.6832298 0.5590278 1.366460   220\n```\n\n\n:::\n:::\n\n\n\n### Confianza:\n\nAhora va a analizar las reglas ordenando por la confianza en la reglas. Recordamos que a mayor confianza, mayor es la fiabilidad de que la presencia de las características en el antecedente de la regla A implicará la presencia de las características en el consecuente de la regla B.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrules <- sort(rules,by=\"confidence\")\ninspect(head(rules)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    lhs                                 rhs                   support confidence  coverage     lift count\n[1] {name==username=No,                                                                                  \n     fake=Si}                        => {external URL=No}   0.4670139          1 0.4670139 1.131631   269\n[2] {description length=muy corto,                                                                       \n     fake=Si}                        => {external URL=No}   0.4531250          1 0.4531250 1.131631   261\n[3] {name==username=No,                                                                                  \n     description length=muy corto,                                                                       \n     fake=Si}                        => {external URL=No}   0.4253472          1 0.4253472 1.131631   245\n[4] {nums/length fullname=muy bajo,                                                                      \n     fake=Si}                        => {external URL=No}   0.4218750          1 0.4218750 1.131631   243\n[5] {profile pic=Si,                                                                                     \n     nums/length fullname=muy bajo,                                                                      \n     #followers=muy alto}            => {name==username=No} 0.4166667          1 0.4166667 1.035971   240\n[6] {nums/length fullname=muy bajo,                                                                      \n     name==username=No,                                                                                  \n     fake=Si}                        => {external URL=No}   0.4097222          1 0.4097222 1.131631   236\n```\n\n\n:::\n:::\n\n\n\nEn este caso, la confianza es 1, lo que significa que el 100% de las transacciones que tienen el antecedente también tienen el consecuente.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2 <- subset(rules, subset = rhs %in% c(\"fake=Si\"))\ninspect(head(r2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    lhs                                 rhs         support confidence  coverage     lift count\n[1] {external URL=No,                                                                          \n     #posts=muy bajo}                => {fake=Si} 0.3072917  0.9567568 0.3211806 1.913514   177\n[2] {fullname words=muy corto,                                                                 \n     name==username=No,                                                                        \n     description length=muy corto,                                                             \n     external URL=No}                => {fake=Si} 0.3454861  0.8122449 0.4253472 1.624490   199\n[3] {fullname words=muy corto,                                                                 \n     name==username=No,                                                                        \n     description length=muy corto}   => {fake=Si} 0.3454861  0.8024194 0.4305556 1.604839   199\n[4] {fullname words=muy corto,                                                                 \n     nums/length fullname=muy bajo,                                                            \n     description length=muy corto,                                                             \n     external URL=No}                => {fake=Si} 0.3072917  0.7972973 0.3854167 1.594595   177\n[5] {fullname words=muy corto,                                                                 \n     nums/length fullname=muy bajo,                                                            \n     description length=muy corto}   => {fake=Si} 0.3072917  0.7866667 0.3906250 1.573333   177\n[6] {fullname words=muy corto,                                                                 \n     name==username=No,                                                                        \n     external URL=No}                => {fake=Si} 0.3750000  0.7105263 0.5277778 1.421053   216\n```\n\n\n:::\n:::\n\n\n\n### Lift:\n\nPor ultimo, vamos a analizar las reglas ordenando primero por el lift de la reglas. Recordamos que un lift alto indica que la presencia de A incrementa significativamente la probabilidad de que B ocurra, lo que sugiere una fuerte asociación entre las características.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrules <- sort(rules,by=\"lift\")\ninspect(head(rules)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    lhs                                 rhs                     support confidence  coverage     lift count\n[1] {name==username=No,                                                                                    \n     #follows=muy alto,                                                                                    \n     fake=No}                        => {#followers=muy alto} 0.3506944  0.9223744 0.3802083 2.059255   202\n[2] {profile pic=Si,                                                                                       \n     #follows=muy alto,                                                                                    \n     fake=No}                        => {#followers=muy alto} 0.3472222  0.9216590 0.3767361 2.057657   200\n[3] {profile pic=Si,                                                                                       \n     name==username=No,                                                                                    \n     #follows=muy alto,                                                                                    \n     fake=No}                        => {#followers=muy alto} 0.3472222  0.9216590 0.3767361 2.057657   200\n[4] {nums/length fullname=muy bajo,                                                                        \n     #follows=muy alto,                                                                                    \n     fake=No}                        => {#followers=muy alto} 0.3437500  0.9209302 0.3732639 2.056030   198\n[5] {nums/length fullname=muy bajo,                                                                        \n     name==username=No,                                                                                    \n     #follows=muy alto,                                                                                    \n     fake=No}                        => {#followers=muy alto} 0.3437500  0.9209302 0.3732639 2.056030   198\n[6] {nums/length username=muy bajo,                                                                        \n     #follows=muy alto,                                                                                    \n     fake=No}                        => {#followers=muy alto} 0.3229167  0.9207921 0.3506944 2.055722   186\n```\n\n\n:::\n:::\n\n\n\nEn este caso, el lift es 5.731343, lo que sugiere que la aparicion de \"external URL=Si\" es aproximadamente 5.73 veces más probable cuando se dan las condiciones en el antecedente.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2 <- subset(rules, subset = rhs %in% c(\"fake=Si\")) \ninspect(head(r2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    lhs                                 rhs         support confidence  coverage     lift count\n[1] {external URL=No,                                                                          \n     #posts=muy bajo}                => {fake=Si} 0.3072917  0.9567568 0.3211806 1.913514   177\n[2] {fullname words=muy corto,                                                                 \n     name==username=No,                                                                        \n     description length=muy corto,                                                             \n     external URL=No}                => {fake=Si} 0.3454861  0.8122449 0.4253472 1.624490   199\n[3] {fullname words=muy corto,                                                                 \n     name==username=No,                                                                        \n     description length=muy corto}   => {fake=Si} 0.3454861  0.8024194 0.4305556 1.604839   199\n[4] {fullname words=muy corto,                                                                 \n     nums/length fullname=muy bajo,                                                            \n     description length=muy corto,                                                             \n     external URL=No}                => {fake=Si} 0.3072917  0.7972973 0.3854167 1.594595   177\n[5] {fullname words=muy corto,                                                                 \n     nums/length fullname=muy bajo,                                                            \n     description length=muy corto}   => {fake=Si} 0.3072917  0.7866667 0.3906250 1.573333   177\n[6] {fullname words=muy corto,                                                                 \n     name==username=No,                                                                        \n     external URL=No}                => {fake=Si} 0.3750000  0.7105263 0.5277778 1.421053   216\n```\n\n\n:::\n:::\n\n\n\n## \n\n## Visualizacion de reglas\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(rules)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTo reduce overplotting, jitter is added! Use jitter = 0 to prevent jitter.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](reglasAsociacion_files/figure-pdf/unnamed-chunk-18-1.pdf){fig-pos='H'}\n:::\n:::\n",
    "supporting": [
      "reglasAsociacion_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}